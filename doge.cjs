#!/usr/bin/env node
const dogecore = require("bitcore-lib-doge");
const axios = require("axios");
const axiosRetry = require("axios-retry").default;
const cheerio = require("cheerio");
const dotenv = require("dotenv");
const mime = require("mime-types");
const express = require("express");
const prompts = require("prompts");
const JSON5 = require("json5");
const { PrivateKey, Address, Transaction, Script, Opcode } = dogecore;
const { Signature, Hash } = dogecore.crypto;
dotenv.config();
const fs = require("fs");
const RPC_URL = process.env.NODE_RPC_URL || "http://127.0.0.1:22555";
const RPC_AUTH = {
    username: process.env.NODE_RPC_USER || "rpc_user",
    password: process.env.NODE_RPC_PASS || "rpc_password"
};
axiosRetry(axios, { retries: 10, retryDelay: axiosRetry.exponentialDelay });
if (process.env.TESTNET === "true") {
  dogecore.Networks.defaultNetwork = dogecore.Networks.testnet;
}
const USE_DYNAMIC_FEES = process.env.DYNAMIC_FEES === "true";
Transaction.FEE_PER_KB = parseInt(process.env.FEE_PER_KB) || 100000000;
const WALLET_PATH = process.env.WALLET || ".wallet.json";
const DUST_THRESHOLD = 0.001 * 1e8;
const MAX_CHUNK_LEN = 520;
const MAX_PAYLOAD_LEN = 1500;
const ORD = process.env.ORD || "https://wonky-ord-v2.dogeord.io";
const DRC20_API = process.env.DRC20_API || "https://api.ordifind.com/drc20/balance";
const DOGGY_MARKET_API = process.env.DOGGY_MARKET_API || "https://api.doggy.market";
const ordApi = axios.create({ baseURL: ORD, timeout: 100000 });
const drc20Api = axios.create({ baseURL: DRC20_API, timeout: 100000 });
const doggyMarketApi = axios.create({ baseURL: DOGGY_MARKET_API, timeout: 100000, headers: {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'} });
const STEPS = [
  0n, 26n, 702n, 18278n, 475254n, 12356630n, 321272406n, 8353082582n,
  217180147158n, 5646683826134n, 146813779479510n, 3817158266467286n,
  99246114928149462n, 2580398988131886038n, 67090373691429037014n,
  1744349715977154962390n, 45353092615406029022166n,
  1179180408000556754576342n, 30658690608014475618984918n,
  797125955808376366093607894n, 20725274851017785518433805270n,
  538857146126462423479278937046n, 14010285799288023010461252363222n,
  364267430781488598271992561443798n, 9470953200318703555071806597538774n,
  246244783208286292431866971536008150n, 6402364363415443603228541259936211926n,
  166461473448801533683942072758341510102n,
];
const SUBSIDY_HALVING_INTERVAL_10X = 2100000n;
const FIRST_DUNE_HEIGHT = 5084000n;
function minimumAtHeight(height) {
  const offset = BigInt(height) + 1n;
  const INTERVAL = SUBSIDY_HALVING_INTERVAL_10X / 12n;
  const start = FIRST_DUNE_HEIGHT;
  const end = start + SUBSIDY_HALVING_INTERVAL_10X;
  if (offset < start) return BigInt(STEPS[12]);
  if (offset >= end) return 0n;
  const progress = offset - start;
  const length = 12 - Math.floor(Number(progress / INTERVAL));
  const startValue = BigInt(STEPS[length]);
  const endValue = BigInt(STEPS[length - 1]);
  const remainder = progress % INTERVAL;
  return startValue - ((startValue - endValue) * remainder) / INTERVAL;
}
function stringToCharCodes(inputString) {
  const charCodes = [];
  for (let i = 0; i < inputString.length; i++) {
    charCodes.push(inputString.charCodeAt(i));
  }
  return charCodes;
}
const IDENTIFIER = stringToCharCodes(process.env.PROTOCOL_IDENTIFIER || "D");
const MAX_OP_RETURN_BYTES = 80;
const MARKETPLACES = { doggymarket: "https://doggy.market", dogelabs: "https://doge-labs.com" };

async function rpcCall(method, params = []) {
  try {
    const res = await axios.post(RPC_URL, { jsonrpc: "1.0", id: "doginals", method, params }, { auth: RPC_AUTH });
    if (res.data.error) { console.error(`RPC Error: ${JSON.stringify(res.data.error)}`); throw new Error(res.data.error.message); }
    return res.data.result;
  } catch (e) { console.error(`RPC ${method} failed: ${e.message}. Full error:`, e.response?.data); throw e; }
}
async function getRawTransaction(txid, verbose = 1, blockhash = null) { const params = blockhash ? [txid, verbose, blockhash] : [txid, verbose]; return await rpcCall("getrawtransaction", params); }
async function estimateSmartFee(confTarget = 6, estimateMode = "CONSERVATIVE") { try { const res = await rpcCall("estimatesmartfee", [confTarget, estimateMode]); if (res.feerate <= 0) throw new Error("Invalid fee estimate"); return Math.ceil(res.feerate * 1e8); } catch (e) { console.warn(`estimatesmartfee failed: ${e.message}. Using default FEE_PER_KB.`); return parseInt(process.env.FEE_PER_KB) || 100000000; } }
async function getMempoolInfo() { return rpcCall("getmempoolinfo"); }
async function getBalance(account = "", minconf = 1, includeWatchonly = false) { try { const balance = await rpcCall("getbalance", [account, minconf, includeWatchonly]); return balance * 1e8; } catch (e) { console.warn(`getbalance failed: ${e.message}. Returning 0.`); return 0; } }
async function listUnspent(minconf = 0, maxconf = 9999999, addresses = [], includeUnsafe = true, queryOptions = {}) { try { const utxos = await rpcCall("listunspent", [minconf, maxconf, addresses, includeUnsafe, queryOptions]); return utxos.map(u => ({ txid: u.txid, vout: u.vout, script: u.scriptPubKey, satoshis: Math.round(u.amount * 1e8), confirmations: u.confirmations || 0, type: "spendable" })); } catch (e) { console.warn(`listunspent failed: ${e.message}. Falling back to ORD API.`); return await fetchAllUnspentOutputs(addresses[0]); } }
async function listTransactions(account = "*", count = 10000, skip = 0, includeWatchonly = true) { try { return await rpcCall("listtransactions", [account, count, skip, includeWatchonly]); } catch (e) { console.warn(`listtransactions failed: ${e.message}. Returning empty list.`); return []; } }
function safeJsonParse(buf) { try { return JSON5.parse(buf.toString("utf-8")); } catch (e) { return null; } }
function detectMimeType(buffer, filename = "", apiContentType = null) { if (apiContentType) return apiContentType; const content = buffer.toString("utf-8").trim(); try { const json = JSON.parse(content); if (json.p === "drc-20" || json.p === "drct") return "application/drc20"; if (json.p === "dogemaps") return "application/dogemap"; if (json.p === "dns") return "application/dns"; if (json.p === "delegate") return "application/delegate"; } catch {} if (filename.match(/\.dogemap$/i) || content.match(/\.dogemap$/)) return "application/dogemap"; if (buffer.slice(0, 2).equals(Buffer.from([0xff, 0xd8]))) return "image/jpeg"; if (buffer.slice(0, 8).equals(Buffer.from([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]))) return "image/png"; return "application/octet-stream"; }
async function getInscriptionIdForUtxo(txid, vout) { try { const res = await ordApi.get(`/output/${txid}:${vout}`); const $ = cheerio.load(res.data); const inscriptionSection = $('dt:contains("inscriptions")').next('dd'); const inscriptionLink = inscriptionSection.find('a').attr('href'); if (inscriptionLink) { const match = inscriptionLink.match(/\/(shibescription|inscription)\/(.+)$/); if (match) return match[2]; } await getRawTransaction(txid, true); return null; } catch (e) { if (e.response?.status !== 404) { console.warn(`ORD API failed for ${txid}:${vout}: ${e.message}`); } try { const rawTx = await getRawTransaction(txid, true); if (rawTx.vout[vout]) { const scriptHex = rawTx.vout[vout].scriptPubKey.hex; const script = new Script(scriptHex); if (script.isDataOut()) { return `${txid}i${vout}`; } } return null; } catch (rpcErr) { console.warn(`RPC fallback failed for ${txid}:${vout}: ${rpcErr.message}`); return null; } } }
async function getInscriptionDetails(inscriptionId) { try { const res = await ordApi.get(`/inscription/${inscriptionId}`); const $ = cheerio.load(res.data); const details = {}; $("dl dt").each((_, el) => { const label = $(el).text().trim(); const dd = $(el).next("dd"); const value = dd.text().trim(); if (label === "content type") details.contentType = value; if (label === "content length") details.contentLength = parseInt(value.replace(' bytes', ''), 10); if (label === "id") details.id = value; if (label === "timestamp") details.inscribedAt = dd.find('time').text(); if (label === "genesis height") details.blockHeight = parseInt(dd.text(), 10); if (label === "genesis fee") details.genesisFee = parseInt(value, 10); if (label === "genesis transaction") details.genesisTx = dd.text(); if (label === "location") details.location = value; if (label === "output") details.output = dd.text(); if (label === "offset") details.offset = parseInt(value, 10); if (label === "output value") details.outputValue = parseInt(value, 10); if (label === "address") details.owner = value; }); details.inscriptionNumber = $('h1').text().match(/Shibescription (\d+)/)?.[1] || null; try { const raw = await getRawTransaction(details.genesisTx, true); const vin = raw.vin[0]; const prevTx = await getRawTransaction(vin.txid, true); const prevOutput = prevTx.vout[vin.vout]; details.inscribedBy = Script.fromHex(prevOutput.scriptPubKey.hex).toAddress().toString(); if (raw.confirmations) { details.blockHeight = (await getBlockCount()) - raw.confirmations; details.inscribedAt = raw.time ? new Date(raw.time * 1000).toISOString() : details.inscribedAt; } } catch (rpcErr) { console.warn(`RPC enhancement failed for ${inscriptionId}: ${rpcErr.message}`); } details.listed = false; details.txs = [details.genesisTx]; return details; } catch (e) { console.warn(`ORD API failed for ${inscriptionId}: ${e.message}`); try { const [txid, vout] = inscriptionId.split("i"); const raw = await getRawTransaction(txid, true); const output = raw.vout[parseInt(vout)]; const details = { contentType: output?.scriptPubKey?.type === 'nulldata' ? 'application/octet-stream' : 'application/octet-stream', contentLength: 0, id: inscriptionId, genesisTx: txid, output: `${txid}:${vout}`, outputValue: Math.round(output.value * 1e8), owner: output.scriptPubKey.addresses?.[0] || null, offset: 0, blockHeight: raw.confirmations ? await getBlockCount() - raw.confirmations : null, inscribedAt: raw.time ? new Date(raw.time * 1000).toISOString() : null, genesisFee: null, location: `${txid}:${vout}:0`, inscriptionNumber: null, listed: false, txs: [txid] }; const vin = raw.vin[0]; const prevTx = await getRawTransaction(vin.txid, true); const prevOutput = prevTx.vout[vin.vout]; details.inscribedBy = Script.fromHex(prevOutput.scriptPubKey.hex).toAddress().toString(); return details; } catch (rpcErr) { console.warn(`RPC fallback failed for ${inscriptionId}: ${rpcErr.message}`); return null; } } }
async function getMempoolMetrics() { try { const mempool = await getMempoolInfo(); const txCount = mempool.size; const bytes = mempool.bytes; const maxMempool = mempool["maxmempool"]; const mempoolMinFee = mempool.mempoolminfee * 1e8; const rawMempool = await rpcCall("getrawmempool", [true]); let totalFee = 0; let totalVsize = 0; let count = 0; for (const [txid, entry] of Object.entries(rawMempool).slice(0, 100)) { totalFee += entry.fee * 1e8; totalVsize += entry.vsize; count++; } const avgFeeRate = count > 0 ? (totalFee / totalVsize) : mempoolMinFee; return { txCount, chains: Object.values(rawMempool).filter(tx => tx.depends?.length > 0).length, avgFeeRate: Number(avgFeeRate.toFixed(2)), bytes, maxMempool }; } catch (e) { console.warn(`Failed to fetch mempool metrics: ${e.message}`); if (fs.existsSync("mempool.json")) { const mempool = JSON.parse(fs.readFileSync("mempool.json")); const txCount = Object.keys(mempool).length; const chains = Object.values(mempool).filter((tx) => tx.depends.length > 0).length; const avgFeeRate = Object.values(mempool).reduce((acc, tx) => acc + (tx.fee / tx.size), 0) / txCount; return { txCount, chains, avgFeeRate: Number(avgFeeRate.toFixed(2)) }; } return null; } }
async function rebuildWallet() { const wallet = JSON.parse(fs.readFileSync(WALLET_PATH)); console.log("🔄 Rebuilding wallet..."); const txids = wallet.utxos.map((u) => u.txid); const checked = []; for (const txid of txids) { try { const raw = await axios.post(RPC_URL, { jsonrpc: "1.0", id: "doginals", method: "getrawtransaction", params: [txid, true] }, { auth: RPC_AUTH }); if (!raw.data.result.confirmations) { console.log(` - TX ${txid} missing or unconfirmed`); } else { checked.push(txid); } } catch { console.warn(` - TX ${txid} not found. Removing.`); } } wallet.utxos = wallet.utxos.filter((u) => checked.includes(u.txid)); fs.writeFileSync(WALLET_PATH, JSON.stringify(wallet, null, 2)); console.log("🔍 Re-classifying UTXOs..."); await walletBalance(); console.log("✅ Rebuild complete."); }
const RATE_LIMIT_CACHE_PATH = "./delegate_rate_limit.json";
function loadRateLimitCache() { try { if (fs.existsSync(RATE_LIMIT_CACHE_PATH)) { return JSON.parse(fs.readFileSync(RATE_LIMIT_CACHE_PATH)); } return {}; } catch (e) { console.warn(`Warning: Failed to load rate limit cache: ${e.message}`); return {}; } }
function saveRateLimitCache(cache) { fs.writeFileSync(RATE_LIMIT_CACHE_PATH, JSON.stringify(cache, null, 2)); }
async function handleWallet() { const subcmd = process.argv[3]; switch (subcmd) { case "new": return walletNew(); case "sync": return await walletSync(); case "balance": return await walletBalance(); case "send": return await walletSend(); case "sendutxo": return await walletSendUTXO(); case "split": return await walletSplit(); default: throw new Error(`Unknown wallet subcommand: ${subcmd}`); } }
async function doge20() { const subcmd = process.argv[3]; switch (subcmd) { case "deploy": return await doge20Deploy(); case "mint": return await doge20Transfer("mint"); case "transfer": return await doge20Transfer("transfer"); default: throw new Error(`Unknown doge20 subcommand: ${subcmd}`); } }
async function doge20Deploy() { const address = process.argv[4]; const ticker = process.argv[5]; const max = process.argv[6]; const limit = process.argv[7]; const decimals = process.argv[8] || "18"; const wallet = JSON.parse(fs.readFileSync(WALLET_PATH)); try { if (!Address.isValid(address)) throw new Error("Invalid address"); if (!ticker.match(/^[A-Za-z]{3,4}$/)) throw new Error("Ticker must be 3 or 4 letters"); if (!max || isNaN(max) || Number(max) <= 0) throw new Error("Max must be a positive number"); if (!limit || isNaN(limit) || Number(limit) <= 0) throw new Error("Limit must be a positive number"); if (isNaN(decimals) || Number(decimals) < 0) throw new Error("Decimals must be a non-negative number"); } catch (e) { console.error(`Validation error: ${e.message}`); process.exit(1); } const doge20Tx = { p: "drc-20", op: "deploy", tick: ticker.toLowerCase(), max, lim: limit, dec: decimals, meta: { deployer: wallet.address, timestamp: Math.floor(Date.now() / 1000) }, }; const data = Buffer.from(JSON5.stringify(doge20Tx)); console.log(`Deploying DRC-20 token: ${ticker} to ${address}`); const txs = inscribe(wallet, new Address(address), "application/json", data); await broadcastAll(txs, wallet); console.log("DRC-20 Deploy TXID:", txs[txs.length - 1].hash); }
async function doge20Transfer(op = "transfer") { const address = process.argv[4]; const ticker = process.argv[5]; const amount = process.argv[6]; const to = op === "transfer" ? process.argv[7] : undefined; const repeat = Number(process.argv[8]) || 1; const wallet = JSON.parse(fs.readFileSync(WALLET_PATH)); try { if (!Address.isValid(address)) throw new Error("Invalid address"); if (!ticker.match(/^[A-Za-z]{3,4}$/)) throw new Error("Ticker must be 3 or 4 letters"); if (!amount || isNaN(amount) || Number(amount) <= 0) throw new Error("Amount must be a positive number"); if (op === "transfer" && !Address.isValid(to)) throw new Error("Invalid recipient address"); if (isNaN(repeat) || repeat <= 0) throw new Error("Repeat must be a positive number"); } catch (e) { console.error(`Validation error: ${e.message}`); process.exit(1); } const doge20Tx = { p: "drc-20", op, tick: ticker.toLowerCase(), amt: amount, ...(to && { to }), meta: { timestamp: Math.floor(Date.now() / 1000) }, }; const data = Buffer.from(JSON5.stringify(doge20Tx)); for (let i = 0; i < repeat; i++) { console.log(`${op === "mint" ? "Minting" : "Transferring"} DRC-20 token: ${ticker}, ${i + 1} of ${repeat}`); const txs = inscribe(wallet, new Address(address), "application/json", data); await broadcastAll(txs, wallet); console.log(`DRC-20 ${op} TXID:`, txs[txs.length - 1].hash); } }
async function walletSync() { const wallet = JSON.parse(fs.readFileSync(WALLET_PATH)); console.log("Syncing UTXOs with RPC and ORD API..."); let rpcUtxos = []; try { rpcUtxos = await listUnspent(0, 9999999, [wallet.address], true); console.log(`RPC fetched ${rpcUtxos.length} UTXOs`); } catch (e) { console.warn(`RPC listunspent failed: ${e.message}. Falling back to ORD API.`); rpcUtxos = await fetchAllUnspentOutputs(wallet.address); console.log(`ORD API fetched ${rpcUtxos.length} UTXOs`); } const unconfirmedBalance = await getUnconfirmedBalance().catch(()=>0); if (unconfirmedBalance > 0) console.log(`Unconfirmed balance: ${unconfirmedBalance / 1e8} DOGE`); const allUtxos = []; rpcUtxos.forEach(ru => allUtxos.push(ru)); try { const ordUtxos = await fetchAllUnspentOutputs(wallet.address); ordUtxos.forEach(ou => { if (!allUtxos.some(ru => ru.txid === ou.txid && ru.vout === ou.vout)) { allUtxos.push(ou); } }); } catch (e) { console.warn(`ORD API fetch failed: ${e.message}`); } console.log(`Total unique UTXOs: ${allUtxos.length}`); wallet.utxos = allUtxos.map(u => ({ txid: u.txid, vout: u.vout, script: u.script, satoshis: u.satoshis, confirmations: u.confirmations, type: "spendable", address: wallet.address, account: "DRC-20 Airdrop" })); fs.writeFileSync(WALLET_PATH, JSON.stringify(wallet, null, 2)); await displayWalletSummary(wallet); }
async function getUnconfirmedBalance() { try { const balance = await rpcCall("getunconfirmedbalance"); return balance * 1e8; } catch { return 0; } }
async function walletBalance() { const wallet = JSON.parse(fs.readFileSync(WALLET_PATH)); if (!wallet.utxos || wallet.utxos.length === 0) { console.log("Wallet state empty, syncing..."); } await walletSync(); }
async function displayWalletSummary(wallet) { const spendable = wallet.utxos.filter(u => u.type === "spendable"); const toDoge = (arr) => arr.reduce((sum, u) => sum + (u.satoshis || 0), 0) / 1e8; const total = toDoge(wallet.utxos); const spend = toDoge(spendable.filter(u => (u.confirmations || 0) > 0)); console.log(`\nWallet synced:\n\n${wallet.address}\n`); console.log(`- Total Balance: ${total.toFixed(8)} DOGE`); console.log(`- Spendable Balance: ${spend.toFixed(8)} DOGE`); }
function walletNew() { if (fs.existsSync(WALLET_PATH)) throw new Error("Wallet already exists"); const privateKey = new PrivateKey(); const wallet = { privkey: privateKey.toWIF(), address: privateKey.toAddress().toString(), utxos: [] }; fs.writeFileSync(WALLET_PATH, JSON.stringify(wallet, null, 2)); console.log("New wallet created:", wallet.address); }
async function walletSend() { const address = process.argv[4]; const amount = parseFloat(process.argv[5]); const message = process.argv[6] || ""; if (!address || isNaN(amount) || amount <= 0) { console.error("❌ Usage: node . wallet send <address> <amount> [optional-message]"); process.exit(1); } if (!Address.isValid(address)) { console.error("❌ Invalid address."); process.exit(1); } if (message && Buffer.from(message, "utf8").length > MAX_OP_RETURN_BYTES) { console.error(`❌ Message exceeds ${MAX_OP_RETURN_BYTES}-byte OP_RETURN limit.`); process.exit(1); } const wallet = JSON.parse(fs.readFileSync(WALLET_PATH)); const sendAmount = Math.floor(amount * 1e8); const FEE_BUFFER = 1000000; const spendables = wallet.utxos.filter((u) => u.type === "spendable" && u.satoshis >= DUST_THRESHOLD && (u.confirmations || 0) > 0); if (spendables.length === 0) { console.error("❌ No confirmed spendable UTXOs available."); process.exit(1); } let selected = []; let total = 0; for (const u of spendables) { selected.push(u); total += u.satoshis; if (total >= sendAmount + FEE_BUFFER) break; } if (total < sendAmount + FEE_BUFFER) { console.error(`❌ Insufficient funds. Needed: ${((sendAmount + FEE_BUFFER) / 1e8).toFixed(8)} DOGE, Available: ${(total / 1e8).toFixed(8)} DOGE`); process.exit(1); } const tx = new Transaction().from(selected).to(address, sendAmount); if (message) { const opReturnData = Buffer.from(message, "utf8").slice(0, MAX_OP_RETURN_BYTES); const opReturnScript = new Script().add("OP_RETURN").add(opReturnData); tx.addOutput(new Transaction.Output({ script: opReturnScript, satoshis: 0 })); } tx.change(wallet.address); tx.sign(wallet.privkey); await broadcast(tx, wallet, true); console.log(`✅ Sent ${amount} DOGE to ${address}`); console.log(`🔁 TXID: ${tx.hash}`); }
async function walletSendUTXO() { const [, , , txid, voutStr, toAddress, msg] = process.argv; const vout = parseInt(voutStr); const wallet = JSON.parse(fs.readFileSync(WALLET_PATH)); const utxo = wallet.utxos.find((u) => u.txid === txid && u.vout === vout); if (!utxo) throw new Error(`UTXO ${txid}:${vout} not found in wallet`); if (utxo.type && utxo.type !== "spendable") { throw new Error(`UTXO ${txid}:${vout} is not spendable (type: ${utxo.type})`); } const tx = new Transaction(); tx.from(utxo); tx.to(toAddress, utxo.satoshis); if (msg) { const opReturn = new Script().add("OP_RETURN").add(Buffer.from(msg)); tx.addOutput(new Transaction.Output({ script: opReturn, satoshis: 0 })); } await fund(wallet, tx); await broadcast(tx, wallet, true); console.log(`UTXO sent with TXID: ${tx.hash}`); }
async function walletSplit() { const count = parseInt(process.argv[4]); const amountPerSplit = process.argv[5] ? Math.floor(parseFloat(process.argv[5]) * 1e8) : null; if (isNaN(count) || count <= 0) { console.error("❌ Usage: node . wallet split <count> [amount_per_split]"); process.exit(1); } const wallet = JSON.parse(fs.readFileSync(WALLET_PATH)); const spendables = wallet.utxos.filter((u) => u.type === "spendable" && u.satoshis >= DUST_THRESHOLD && (u.confirmations || 0) > 0); if (spendables.length === 0) { console.error("❌ No confirmed spendable UTXOs available."); process.exit(1); } const totalSpendable = spendables.reduce((sum, u) => sum + u.satoshis, 0); const estimatedFeePerByte = Math.max(1, Math.floor((await estimateSmartFee()) / 1000)); const estimatedTxSize = 180 + (count * 34) + (spendables.length * 148); const estimatedFee = estimatedTxSize * estimatedFeePerByte; let splitAmount; if (amountPerSplit) { if (isNaN(amountPerSplit) || amountPerSplit <= 0) { console.error("❌ Amount per split must be a positive number."); process.exit(1); } splitAmount = amountPerSplit; const totalNeeded = count * splitAmount + estimatedFee; if (totalSpendable < totalNeeded) { console.error(`❌ Insufficient funds. Required: ${(totalNeeded / 1e8).toFixed(8)} DOGE, Available: ${(totalSpendable / 1e8).toFixed(8)} DOGE`); process.exit(1); } } else { const amountToSplit = totalSpendable - estimatedFee; if (amountToSplit <= 0) { console.error("❌ Insufficient funds for fee."); process.exit(1); } splitAmount = Math.floor(amountToSplit / count); if (splitAmount < DUST_THRESHOLD) { console.error(`❌ Split amount too small (${(splitAmount / 1e8).toFixed(8)} DOGE), would create dust UTXOs.`); process.exit(1); } } const tx = new Transaction().from(spendables); for (let i = 0; i < count; i++) { tx.to(wallet.address, splitAmount); } tx.change(wallet.address); tx.sign(wallet.privkey); await broadcast(tx, wallet, true); console.log(`✅ Split complete. TXID: ${tx.hash}`); }
function bufferToChunk(b) { b = Buffer.from(b); return { buf: b.length ? b : undefined, len: b.length, opcodenum: b.length <= 75 ? b.length : b.length <= 255 ? 76 : 77 }; }
function numberToChunk(n) { return { buf: n <= 16 ? undefined : n < 128 ? Buffer.from([n]) : Buffer.from([n % 256, Math.floor(n / 256)]), len: n <= 16 ? 0 : n < 128 ? 1 : 2, opcodenum: n === 0 ? 0 : n <= 16 ? 80 + n : n < 128 ? 1 : 2 }; }
function IdToChunk(inscription_id) { if (!inscription_id.endsWith("i0")) throw new Error("Provide inscription ID ending with 'i0'"); const txid = inscription_id.slice(0, -2); return { buf: Buffer.from(txid, "hex").reverse(), len: 32, opcodenum: 32 }; }
async function inscribe(wallet, address, contentType, data, delegateTxId = "") { const txs = []; const privateKey = new PrivateKey(wallet.privkey); const publicKey = privateKey.toPublicKey(); const parts = []; const inscription = new Script(); if (delegateTxId) { inscription.add("ord").add(numberToChunk(1)).add(numberToChunk(0)).add(numberToChunk(11)).add(IdToChunk(delegateTxId)); } else { while (data.length) { parts.push(data.slice(0, Math.min(MAX_CHUNK_LEN, data.length))); data = data.slice(MAX_CHUNK_LEN); } inscription.add("ord").add(numberToChunk(parts.length)).add(bufferToChunk(contentType)); parts.forEach((part, n) => { inscription.add(numberToChunk(parts.length - n - 1)).add(bufferToChunk(part)); }); } let p2shInput, lastLock, lastPartial; while (inscription.chunks.length) { const partial = new Script(); if (!txs.length) partial.add(inscription.chunks.shift()); while (partial.toBuffer().length <= MAX_PAYLOAD_LEN && inscription.chunks.length) { partial.add(inscription.chunks.shift()).add(inscription.chunks.shift()); } if (partial.toBuffer().length > MAX_PAYLOAD_LEN) { inscription.chunks.unshift(partial.chunks.pop()); inscription.chunks.unshift(partial.chunks.pop()); } const lock = new Script().add(publicKey.toBuffer()).add(Opcode.OP_CHECKSIGVERIFY); partial.chunks.forEach(() => lock.add(Opcode.OP_DROP)); lock.add(Opcode.OP_TRUE); const lockHash = Hash.ripemd160(Hash.sha256(lock.toBuffer())); const p2sh = new Script().add(Opcode.OP_HASH160).add(lockHash).add(Opcode.OP_EQUAL); const p2shOutput = new Transaction.Output({ script: p2sh, satoshis: 100000 }); const tx = new Transaction(); if (p2shInput) tx.addInput(p2shInput); tx.addOutput(p2shOutput); const availableUtxos = wallet.utxos.filter((u) => u.type === "spendable" && !isUTXOBlocked(u.txid, u.vout)); if (!availableUtxos.length) throw new Error("No spendable UTXOs available for funding"); await fund(wallet, tx, true); if (p2shInput) { const signature = Transaction.sighash.sign(tx, privateKey, Signature.SIGHASH_ALL, 0, lastLock); const txSig = Buffer.concat([signature.toBuffer(), Buffer.from([Signature.SIGHASH_ALL])]); const unlock = new Script().add(lastPartial).add(txSig).add(lastLock.toBuffer()); tx.inputs[0].setScript(unlock); } updateWallet(wallet, tx); txs.push(tx); p2shInput = new Transaction.Input({ prevTxId: tx.hash, outputIndex: 0, output: tx.outputs[0], script: "" }); p2shInput.clearSignatures = () => {}; p2shInput.getSignatures = () => {}; lastLock = lock; lastPartial = partial; } const finalTx = new Transaction().addInput(p2shInput).to(address, 100000); const availableUtxos = wallet.utxos.filter((u) => u.type === "spendable" && !isUTXOBlocked(u.txid, u.vout)); if (!availableUtxos.length) throw new Error("No spendable UTXOs available for funding final transaction"); await fund(wallet, finalTx, true); const signature = Transaction.sighash.sign(finalTx, privateKey, Signature.SIGHASH_ALL, 0, lastLock); const txSig = Buffer.concat([signature.toBuffer(), Buffer.from([Signature.SIGHASH_ALL])]); const unlock = new Script().add(lastPartial).add(txSig).add(lastLock.toBuffer()); finalTx.inputs[0].setScript(unlock); updateWallet(wallet, finalTx); txs.push(finalTx); return txs; }
async function broadcastAll(txs, wallet) { for (let i = 0; i < txs.length; i++) { console.log(`Broadcasting TX ${i + 1}/${txs.length}: ${txs[i].hash}`); await broadcast(txs[i], wallet, true); } }
async function fund(wallet, tx, onlySafe = true) { let availableUtxos = wallet.utxos.filter((u) => { return u.type === "spendable" && !isUTXOBlocked(u.txid, u.vout) && (u.confirmations || 0) > 0; }); if (!availableUtxos.length) { throw new Error("❌ No confirmed spendable UTXOs available"); } availableUtxos.sort((a, b) => b.satoshis - a.satoshis); const targetAmount = tx.outputs.reduce((sum, output) => sum + output.satoshis, 0); const estimatedFeePerByte = Math.max(1, Math.floor((await estimateSmartFee()) / 1000)); const estimatedTxSize = 180 + (tx.outputs.length * 34); let estimatedFee = estimatedTxSize * estimatedFeePerByte; let selectedUtxos = []; let totalInput = 0; for (const utxo of availableUtxos) { selectedUtxos.push(utxo); totalInput += utxo.satoshis; const actualTxSize = 180 + (selectedUtxos.length * 148) + (tx.outputs.length * 34); estimatedFee = actualTxSize * estimatedFeePerByte; if (totalInput >= targetAmount + estimatedFee + DUST_THRESHOLD) { break; } } if (totalInput < targetAmount + estimatedFee) { const needed = (targetAmount + estimatedFee) / 1e8; const available = totalInput / 1e8; throw new Error(`💸 Insufficient funds. Need: ${needed.toFixed(8)} DOGE, Available: ${available.toFixed(8)} DOGE`); } tx.from(selectedUtxos); tx.change(wallet.address); tx.sign(wallet.privkey); const actualFee = tx.getFee(); if (actualFee <= 0) throw new Error("Transaction fee cannot be zero"); console.log(`💰 Transaction fee: ${(actualFee / 1e8).toFixed(8)} DOGE (${selectedUtxos.length} inputs)`); if (actualFee > 100000000) { console.warn(`⚠️ High fee detected: ${(actualFee / 1e8).toFixed(8)} DOGE`); } }
function isUTXOBlocked(txid, vout) { if (!fs.existsSync("utxo.json")) return false; try { const utxos = JSON.parse(fs.readFileSync("utxo.json")); return utxos.some((u) => u.txid === txid && (u.vout === vout || u.vout === undefined)); } catch { return false; } }
async function broadcast(tx, wallet, retry = true) { const req = { jsonrpc: "1.0", id: "doginals", method: "sendrawtransaction", params: [tx.toString()] }; if (process.env.DYNAMIC_FEES === "true") { const metrics = await getMempoolMetrics(); const DEFAULT_FEE = parseInt(process.env.FEE_PER_KB) || 100000000; if (metrics) { if (metrics.txCount > 10000 || metrics.avgFeeRate > 5) { console.warn("⛔ Mempool congestion detected:"); console.warn(` → ${metrics.txCount} txs in mempool, avg fee rate: ${metrics.avgFeeRate} sat/vB`); console.warn("⏳ Delaying broadcast by 30s to avoid rejection..."); await new Promise((r) => setTimeout(r, 30000)); } if (metrics.avgFeeRate > 8) { const feeRate = Math.ceil(metrics.avgFeeRate + 1); console.warn(`⚙️ Increasing FEE_PER_KB to ${feeRate} due to congestion`); Transaction.FEE_PER_KB = feeRate; } else if (metrics.avgFeeRate < 3 && Transaction.FEE_PER_KB > DEFAULT_FEE) { console.log(`✅ Mempool cleared. Restoring FEE_PER_KB to default: ${DEFAULT_FEE}`); Transaction.FEE_PER_KB = DEFAULT_FEE; } } } let res; while (true) { try { res = await axios.post(RPC_URL, req, { auth: RPC_AUTH }); break; } catch (e) { if (!retry) throw e; const msg = e.response?.data?.error?.message; if (msg?.includes("too-long-mempool-chain")) { console.warn("🔁 Retrying due to too-long-mempool-chain..."); await new Promise((r) => setTimeout(r, 1000)); } else { throw e; } } } updateWallet(wallet, tx); fs.writeFileSync(WALLET_PATH, JSON.stringify(wallet, null, 2)); return res.data.result; }
function updateWallet(wallet, tx) { wallet.utxos = wallet.utxos.filter((u) => !tx.inputs.some((i) => i.prevTxId.toString("hex") === u.txid && i.outputIndex === u.vout)); tx.outputs.forEach((o, i) => { if (o.script.toAddress()?.toString() === wallet.address) { wallet.utxos.push({ txid: tx.hash, vout: i, script: o.script.toHex(), satoshis: o.satoshis, type: "spendable" }); } }); }
async function fetchAllUnspentOutputs(walletAddress) { const response = await ordApi.get(`utxos/balance/${walletAddress}?show_all=true&show_unsafe=true`); return (response.data.utxos || []).map((o) => ({ txid: o.txid, vout: o.vout, script: o.script, satoshis: Number(o.shibes) })); }
async function getBlockCount() { try { const response = await axios.post(RPC_URL, { jsonrpc: "1.0", id: "doginals", method: "getblockcount", params: [], }, { auth: RPC_AUTH }); return response.data.result; } catch (e) { throw new Error(`Failed to fetch block count: ${e.message}`); } }
async function isDune(txid) { try { const res = await ordApi.get(`/output/${txid}:0`); const $ = cheerio.load(res.data); return $("table tr").length > 1; } catch { return false; } }
function server() { const app = require('express')(); const port = process.env.SERVER_PORT ? parseInt(process.env.SERVER_PORT) : 3000; app.get("/tx/:txid", async (req, res) => { res.status(501).send("Not Implemented"); }); app.listen(port, () => { console.log(`Listening on port ${port}`); }); }
async function main() { const cmd = process.argv[2]; switch (cmd) { case "wallet": return await handleWallet(); case "mint": return await mint(); case "doge20": return await doge20(); case "server": return server(); default: console.error(`Unknown command: ${cmd}`); process.exit(1); } }
main().catch((e) => { const reason = e.response?.data?.error?.message || e.message; console.error(`Error: ${reason}`); process.exit(1); });

